---
title: 630-课程表 III
toc: true
date: 2020-09-21 23:46:17
tags: 优先队列
categories: LeetCode
---

这里有 `n` 门不同的在线课程，他们按从 `1` 到 `n` 编号。每一门课程有一定的持续上课时间（课程时间）`t` 以及关闭时间第 `d` 天。一门课要持续学习 `t` 天直到第 `d` 天时要完成，你将会从第 `1` 天开始。

给出 `n` 个在线课程用 `(t, d)` 对表示。你的任务是找出最多可以修几门课。

 
**示例**：

```
输入: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
输出: 3
解释: 
这里一共有 4 门课程, 但是你最多可以修 3 门:
首先, 修第一门课时, 它要耗费 100 天，你会在第 100 天完成, 在第 101 天准备下门课。
第二, 修第三门课时, 它会耗费 1000 天，所以你将在第 1100 天的时候完成它, 以及在第 1101 天开始准备下门课程。
第三, 修第二门课时, 它会耗时 200 天，所以你将会在第 1300 天时完成它。
第四门课现在不能修，因为你将会在第 3300 天完成它，这已经超出了关闭日期。
```

**提示**:

整数 `1 <= d`, `t,n <= 10,000` 。
你不能同时修两门课程。

<!-- more -->

# 解法

在本题中我们首先想到的就是对所有课程按照最晚结束时间升序排列，因为早结束的课程我们肯定会优先安排。

接下来我们观察到，如果在第 `0` 天到第 `i` 天最多选择 `k` 门课程，那么有 `c1 + c2 + ... + ck <= di`, 那么接下来在第 `i + 1` 天，如果 `c1 + c2 + ... + ck + ci+1<= di+1`, 那么我们直接选择第 `i+1` 门课就行了。如果 `c1 + c2 + ... + ck + ci+1 >= di+1`, 那么我们则可以挑选这 `k + 1` 天中耗时最长的课程从课程中删去，这样我们才会有最多的空余时间安排接下来的课程。

由于我们需要随时找出所有课程中时间最长的课程，因此我们使用大顶堆来解决。

**代码**

```java
import java.util.*;

class Solution {
    public int scheduleCourse(int[][] courses) {
        PriorityQueue<Integer> q = new PriorityQueue<>((a,b)->b-a);
        Arrays.sort(courses, (c1, c2) -> c1[1] - c2[1]);
        int curr = 0;

        for (int [] course:courses) {
            curr += course[0];
            q.add(course[0]);
            if(curr > course[1]){
                curr -= q.poll();
            }
        }

        return q.size();
    }
}
```
