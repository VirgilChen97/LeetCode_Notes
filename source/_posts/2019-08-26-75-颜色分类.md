---
title: 75-颜色分类
date: 2019-08-26 17:11:56
tags: 指针
Category: LeetCode
---

# 题目

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

**注意:**<br>
不能使用代码库中的排序函数来解决这道题。

## 例子

```plain
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```

## 进阶

- 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。

- 你能想出一个仅使用常数空间的一趟扫描算法吗？

# 解法

## 三指针法

设定一个左指针 `l` 指向左侧0的边界，设定一个右指针 `r` 指向右侧2的边界，在使用一个指针 `i` 对数组进行扫描, 如果 `nums[i] = 0` 则交换 `nums[i]` 和 `nums[l]`, 若 `nums[i] = 2` , 则交换 `nums[i]` 和 `nums[r]`。

- While `i <= r` :
  - 若 `nums[i] = 0` ：交换第 `i` 个和第 `l` 个元素，并将指针都向右移。
    - 都向右移动的原因是此时 `i` 左侧的元素全部都被扫描过了，不需要再次扫描
  - 若 `nums[i] = 2` ：交换第 `i` 个和第 `r` 个元素，并将 `r` 指针左移 。
    - 不移动 `i` 指针的原因是此时从右侧换来的元素是未知的，需要重新判断
  - 若 `nums[i] = 1` ：将指针 `i` 右移。

### 代码

```java
class Solution {
    public void sortColors(int[] nums) {
        int l = 0;
        int r = nums.length - 1;
        int i = 0;
        while(i <= r){
            if(nums[i] == 0){
                int temp = nums[l];
                nums[l++] = nums[i];
                nums[i++] = temp;
            }else if(nums[i] == 2){
                int temp = nums[r];
                nums[r--] = nums[i];
                nums[i] = temp;
            }else{
                i++;
            }
        }
    }
}
```