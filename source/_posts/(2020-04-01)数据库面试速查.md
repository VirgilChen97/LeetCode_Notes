---
title: 数据库面试速查
date: 2020-04-01 12:54:02
tags: 数据库
categories: 面试
---

记录在数据库面试中常见的问题

<!--more-->

# innoDB 和 MyISAM 区别

1. InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一
2. InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  
3. InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 
4. InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快
5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；

# 索引

物理角度

1. 聚集索引
2. 非聚集索引

数据结构角度

1. Hash索引
2. B+树索引
3. 全文索引

什么时候会不能使用索引

1. 负向查询 （not in）
2. 前导模糊查询
3. 不能对索引字段进行计算
4. 复合索引只有查询第一列和全部才能使用索引

# 乐观锁和悲观锁

### 1. 悲观锁（多写）

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。

### 2. 乐观锁（多读）

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制

# 数据库事务隔离级别

### 1. Read Uncommitted

在一个事务中可以读取到其他事务中没有commit的数据，所有隔离级别最低的一种。会产生**脏读**，如果这个时候事务由于某种原因被撤销，其他人可能读取到本不应该出现在数据库中的数据。

### 2. Read Committed

一个事务只能读取到其他事务提交以后的数据

但是会出现**不可重复读**问题，即事务A读取了数据，但是此时事务B更新了数据并提交了事务，当事务A读取该数据时数据发生了改变。

### 3. Repeatable 

在同一个事务中，查询结果必须保持一致，即在事务A中读取了某一数据，那么在事务A没有结束之前，其他事务不能修改此数据。

但是会出现**幻读**问题，是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。

### 4. Serializable

最严格的事务隔离，要求事务必须序列化执行

# 数据库范式

1. **1NF**：强调的是列的原子性，即列不能够再分成其他几列。
2. **2NF**：表必须有主键，且必须完全依赖于主键
3. **3NF**：非主属性不能依赖与其他非主属性（传递依赖）