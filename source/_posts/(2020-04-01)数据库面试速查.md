---
title: 数据库知识点整理
date: 2020-04-01 12:54:02
tags: 数据库
categories: 面试
---

记录在数据库面试中常见的问题

<!--more-->

# Mysql 事务

数据库的事务是指一组sql语句组成的数据库逻辑处理单元，在这组的sql操作中，要么全部执行成功，要么全部执行失败。例如银行转账，包括了从账户 A 扣款和给账户 B 加钱的两个操作，这两个操作要么全部完成，要么全部失败。

# ACID 简介

1. **(A)tomicity**, 原子性是指事务的原子性操作，对数据的修改要么全部执行成功，要么全部失败，实现事务的原子性，是基于日志的 `Redo/Undo` 机制。
2. **(C)onsistency**，一致性指的是在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。
3. **(I)solation**，数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。这和数据库的事务隔离级别有关。
4. **(D)urability**，事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

# Undo/Redo 机制

## Redo

Redo log用来记录某数据块被修改后的值，可以用来恢复未写入 data file 的已成功事务更新的数据。主要用作数据库的崩溃恢复。MySql 官方文档中介绍 redo log 是一种记录在磁盘上的数据结构，它在错误恢复中被用于纠正未完成的事务产生的错误数据。

### 组成

Redo log 分为两个部分：

- 内存中的 redo log buffer，易失
- 磁盘上的 redo log file，持久

### 什么时候写 Redo log

Innodb 通过 “Force log at commit” 来实现事务的持久性，也就是事务提交的时候必须把该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。

- 在数据页修改完成之后，在脏页刷出磁盘之前，写入redo日志。注意的是先修改数据，后写日志
- redo日志比数据页先写回磁盘
- 聚集索引、二级索引、undo页面的修改，均需要记录Redo日志。

## Undo 

Undo log是用来记录数据更新前的值，保证数据更新失败能够回滚。同时系统崩溃时，可能有些事务还没有COMMIT，在系统恢复时，这些没有COMMIT的事务就需要借助undo log来进行回滚。

### 什么时候写 Undo log

- 修改某一记录前写undo log到缓存
- 提交前将将undo log写到磁盘

## 实际流程

假设有A、B两个数据，值分别为1,2，开始一个事务，事务的操作内容为：把1修改为3，2修改为4，那么实际的记录如下（简化）：

1. 事务开始.
2. 记录A=1到undo log.
3. 修改A=3.
4. 记录A=3到redo log.
5. 记录B=2到undo log.
6. 修改B=4.
7. 记录B=4到redo log.
8. 将redo log写入磁盘
9. 事务提交

# 数据库事务隔离级别

### 1. Read Uncommitted

在一个事务中可以读取到其他事务中没有commit的数据，所有隔离级别最低的一种。会产生**脏读**，如果这个时候事务由于某种原因被撤销，其他人可能读取到本不应该出现在数据库中的数据。

### 2. Read Committed

一个事务只能读取到其他事务提交以后的数据

但是会出现**不可重复读**问题，即事务A读取了数据，但是此时事务B更新了数据并提交了事务，当事务A读取该数据时数据发生了改变。

### 3. Repeatable 

在同一个事务中，查询结果必须保持一致，即在事务A中读取了某一数据，那么在事务A没有结束之前，其他事务不能修改此数据。

但是会出现**幻读**问题，是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。

### 4. Serializable

最严格的事务隔离，要求事务必须序列化执行

# MySql 锁机制（InnoDB）

总的来说，InnoDB 共有七种类型的锁：

1. 共享/排它锁(Shared and Exclusive Locks)
2. 意向锁(Intention Locks)
3. 记录锁(Record Locks)
4. 间隙锁(Gap Locks)
5. 临键锁(Next-key Locks)
6. 插入意向锁(Insert Intention Locks)
7. 自增锁(Auto-inc Locks)

## 乐观锁和悲观锁

### 乐观锁（多读）

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制.

### 悲观锁（多写）

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。

## 共享/排它锁 （行锁）

InnoDB 默认使用行锁，默认有两种种类的锁：

- **共享锁（S）**：多个事务可以在同一行上共享锁，但是都只能获取数据但是不能修改
    
    ```sql
    SELECT ... LOCK IN SHARE MODE;
    ```
- **排他锁（X）**：当一个事务上了X锁，那么其他的事务就不能在改行上任何种类的锁
    ```sql
    SELECT ... FOR UPDATE;
    ```

select 语句默认不会加任何锁，而insert，update，delete 操作则会自动加上排他锁。

InnoDB的行锁时通过给索引项加锁来实现的，这意味着只有通过索引条件检索数据，InnoDB才使用行锁，否则将使用表锁。不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。

在InnoDB中，行锁

## 意向锁（表锁）

InnoDB 中除了直接的表锁之外，还实现了一种**意向锁**，意向锁是一种不与行锁冲突的表锁。通常如果一个事务给表中的某一行上了排他锁，那么我们不能在表上加锁。我们如何判断这种锁的冲突呢？

1. 判断表是否已经被其他事务锁住
2. 判断表中的每一行是否被行锁锁住

这就意味着我们需要遍历整张表才能知道是否有某一行被锁住了，因此就有了意向锁。一个事务想要获取某一行的行锁时，要先获取对应的意向锁。

- **意向共享锁（IS）**：它预示着，事务正在或者有意向对表中的”某些行”加S锁。
- **意向排他锁（IX）**：它预示着，事务正在或者有意向对表中的”某些行”加X锁。

来看一下各种锁之间的兼容情况：

|     | IS   | IX   |
| --- | ---- | ---- |
| IS  | true | true |
| IX  | true | true |

|     | S     | X     |
| --- | ----- | ----- |
| IS  | true  | false |
| IX  | false | false |

这样就解决了判断是否有锁需要全表扫描的情况。假设事务 A 给表的某一行上了S锁，那么他首先需要在表上上一个IS锁。此时如果事务 B 想要给表上一个 S 锁，那么 B 只需要去检查表上的意向锁 IS，发现 S 与 IS兼容，成功拿到表锁。而如果事务 B 想要给表上一个 X 锁, IS 和 X不兼容，因此事务 B 阻塞，避免了全表扫描。

## 记录锁、间隙锁、临键锁

**记录锁（Record Lock）** 记录锁就是对某行进行加锁，防止该行被其他操作修改或删除。

**间隙锁（Gap Lock）** 为了在RR级别下解决幻读引入的机制，他会锁定索引之间的间隙（即不存在的元素），其他事务都不能进行修改。不能在当前事务操作的索引范围内插入新值则可以避免幻读的问题。

**临键锁（next-key Lock）** 是记录锁和间隙锁的结合，满足左开右闭原则

## 插入意向锁

**插入意向锁**是在插入一条记录行前，由 INSERT 操作产生的一种间隙锁。该锁用以表示插入意向，当多个事务在同一区间（gap）插入位置不同的多条数据时，事务之间不需要互相等待。假设存在两条值分别为 4 和 7 的记录，两个不同的事务分别试图插入值为 5 和 6 的两条记录，每个事务在获取插入行上独占的（排他）锁前，都会获取（4，7）之间的间隙锁，但是因为数据行之间并不冲突，所以两个事务之间并不会产生冲突（阻塞等待）

# MySQL 索引

## 索引分类

1. **主键索引**：即主索引，在主键上建立的索引，不允许重复，不允许空值
2. **唯一索引**：建立索引的列的值是唯一的，不允许重复，允许空值
3. **普通索引**：普通的索引，无限制
4. **全文索引**：用大文本对象的列构建的索引
5. **组合索引**：用多个列组合构建的索引，这多个列中的值不允许有空值

## 实现方式

### Hash索引

只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。

### B+树索引

使用 B+ 树组织的索引

### 全文索引

针对较大的数据，生成全文索引非常的消耗时间和空间。对于文本的大对象，或者较大的CHAR类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可行的，但是想要匹配文本中间的几个单词，那么就要使用LIKE %word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，这种情况，就可使用时FULLTEXT索引了，在生成FULLTEXT索引时，会为文本生成一份单词的清单，在索引时及根据这个单词的清单来索引。

## 物理角度

## 聚集索引

聚簇索引的顺序就是数据的物理存储顺序。


## 非聚集索引

索引顺序与数据物理排列顺序无关

什么时候会不能使用索引

1. 负向查询 （not in）
2. 前导模糊查询
3. 不能对索引字段进行计算
4. 复合索引只有查询第一列和全部才能使用索引

# innoDB 和 MyISAM 区别

1. InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一
2. InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  
3. InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 
4. InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快
5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；

# 数据库范式

1. **1NF**：强调的是列的原子性，即列不能够再分成其他几列。
2. **2NF**：表必须有主键，且必须完全依赖于主键
3. **3NF**：非主属性不能依赖与其他非主属性（传递依赖）